
# 1. Общий вид дерева

## Запись:
1. полная скобочная ( value LEFT_TREE RIGHT_TREE )
2. отсутствие поддерева - _

## Устройство данных узла
	ТИП_ДАННЫХ ДАННЫЕ
Тип данных определяет смысл данных узла

```c
type(ТИП_ДАННЫХ) = uint_16t
```

```c
switch (ТИП_ДАННЫХ){

	case 1: Ключевое слово

	case 2: Численная костанта (float)

	case 3: Идентификатор
}
```

## Ключевые слова

|Номер|Ключевое слово|
|-|-|
|1|Оператор последовательного исполнения (;)|
|51|=|
|52|\>|
|53|<|
|54|\>=|
|55|<=|
|56|==|
|57|!=|
|101|\+|
|102|\-|
|103|\*|
|104|/|
|105|++|
|106|++|
|107|--|
|108|--|
|201|if|
|202|while|
|203|and|
|204|or|
|301|sin|
|302|cos|
|303|floor|
|304|diff|
|305|sqrt|
|306|ln|
|307|exp|

### Примечание
У унарных операторов используется правое поддерево, левое пустое.

## Идентификаторы

Бекенд не нуждается в таблице имен. Именно поэтому создаётся два файла - с таблицей имён и с деревом соответственно.


### Устройство файла таблицы имён
Каждое имя на своей строке.

Каждая строка начинатеся с уникального числа (uint_16t), потом следует пробел и имя идентификатора вплоть до символа '\n', не включая его.

#### Пример:

```
19 meow

20 bark

21 bark bark bark
```

Значит, что если встречается идентификатор под номером 19 в дереве, то под ним имеется ввиду meow.

21 - идентификатор "bark bark bark" (т.е. сложные идентификаторы поддерживаются).

## Пример дерева и расшифровка с файлом

```c
x = sin(2);

if (x > 0.5){
	y = 0;
}

y++;
```

( 1 1 ( 1 51 ( 3 1 _ _ ) ( 1 301 _ ( 2 2 _ _ ) ) ) ( 1 1 ( 1 201 ( 1 52 ( 3 1 _ _ ) ( 2 0.5 _ _ ) ) ( 1 51 ( 2 2 _ _ ) ( 2 0 _ _ ) ) ) ( 1 105 _ ( 2 2 _ _ ) ) ) )

Таблица имён

1 x

2 y
